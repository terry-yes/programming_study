[../](../)

[../README.md](../README.md)


## 포인터 배열과 배열 포인터

비교대상: `arr[][]`, `*arr[]`, `**arr`

### 1. `arr[][]`  초기화   

```c
#include <stdio.h>

int	main(void)
{
	int		arr1[1][2];

	//arr1[0] = {1, 2}; 실패
	arr1[0][0] = 1;
	arr1[0][1] = 2;
	printf("arr1: %d %d\n", arr1[0][0], arr1[0][1]);
	
}
```

- 선언하면서 바로 초기화 하지 않는이상 일일이 해줘야됨

- 선언할때 초기화하면 {{0,1}} 이런식도 가능j

### 2. 배열 포인터와 포인터 배열

1. 포인터배열: `int *arr[2]` (포인터를 담는 **배열**임)

2. 배열포인터: `int (*arr)[2]`(배열 크기의 포인터)



- 읽는 방법이 어려웠는데 둘다 오른쪽부터가 우선순위 ()가 있으면 더 우선으로 읽으면 됨
  - 포인터배열: `arr[2]`가 오른쪽에 있으니 일단 2칸짜리 배열인데 `int *`를 담고 있음
  - 배열포인터: `*arr`이므로 포인터인데 `int [2]` 크기를 가르키고 있음.
- 포인터 배열의 경우 선언하면 각각의 포인터가 `0X0` 을 가르키고 있음
  즉, 주소를 연결시켜줘야함
- 배열포인터의 경우 
  `test[2][3]`  짜리 배열을 연결시키고 싶을때는 
  `int (*arr)[3]` 으로 만들면 됨 `arr[1]`  이  `arr + 1` 을 뜻하므로 int [3]만큼씩 증가되므로 `test[2][3]`   에서 `[2]` 은 신경안써도됨




###  3. `int (arr[1])[2]` 은?

- 선언할때 오른쪽 부터 읽는다는 사실을 알고 1을 다시 실험 해봤는데
  `int (arr1[1])[2]` 는 `int a arr[2][1]`  이거랑 같음.

